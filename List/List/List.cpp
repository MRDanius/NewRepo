#include <iostream> 

using namespace std; 

const int SIZE = 10; // Константа для определения размера массива

// Функция для объединения двух половин массива 
void merge(int arr[], int left, int mid, int right) {
    // 1 аргумент - сам массив, 2 - индекс начала первой части массива, 
    // 3 - конец первой части начала второй, 4 - конец второй части массива

    int n1 = mid - left + 1; // Вычисляем размер левой половины
    int n2 = right - mid;    // Вычисляем размер правой половины

    // Создаём временные массивы для хранения левой и правой половин
    int* L = new int[n1]; 
    int* R = new int[n2]; 

    // Копируем данные из исходного массива в временные массивы L и R
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i]; // Заполняем левый массив
    for (int i = 0; i < n2; i++)
        R[i] = arr[mid + 1 + i]; // Заполняем правый массив

    int i = 0, j = 0, k = left; // i для прохода по L, j для прохода по R, k для записи в arr

    
    while (i < n1 && j < n2) { // Пока есть элементы в обоих массивах
        if (L[i] <= R[j]) { // Если элемент в левом массиве меньше или равен правому добавляем его в исходный массив
            arr[k++] = L[i++]; 
        }
        else { 
            arr[k++] = R[j++];  //иначе добавляем его в исходный массив
        }
    }

    // Копируем оставшиеся элементы из левого массива, если есть
    while (i < n1) {
        arr[k++] = L[i++]; // Добавляем элементы из левого массива
    }

    // Копируем оставшиеся элементы из правого массива, если есть
    while (j < n2) {
        arr[k++] = R[j++]; // Добавляем элементы из правого массива
    }

    // Освобождаем память, выделенную для временных массивов
    delete[] L; // Удаляем временный массив L
    delete[] R; // Удаляем временный массив R
}

// Функция сортировки слиянием
void mergeSort(int arr[], int left, int right) {
    if (left < right) { // Проверяем, что левый индекс меньше правого
        int mid = left + (right - left) / 2; // Находим середину массива

        mergeSort(arr, left, mid); // Сортируем левую половину
        mergeSort(arr, mid + 1, right); // Сортируем правую половину

        
        merge(arr, left, mid, right); // Объединяем без повторов
    }
}

// Функция для нахождения пересечения двух массивов
int intersection(int A[], int B[], int result[]) {
    int i = 0, j = 0, k = 0; // Индексы для массивов A, B и результирующего массива

    while (i < SIZE && j < SIZE) { // Пока есть элементы в обоих массивах
        if (A[i] == B[j]) { // Если элементы равны проверяем, чтобы элемент не повторялся в результирующем массиве
            if (k == 0 || result[k - 1] != A[i]) {
                result[k++] = A[i]; 
            }
            i++; // Переходим к следующему элементу в массиве A
            j++; // в массиве B
        }
        else if (A[i] < B[j]) { 
            i++;
        }
        else { 
            j++; 
        }
    }
    return k; // Возвращаем количество элементов в пересечении
}

// Функция для нахождения объединения двух массивов
int unionArrays(int A[], int B[], int result[]) {
    int i = 0, j = 0, k = 0; 

    while (i < SIZE && j < SIZE) {
        if (A[i] == B[j]) { // Если элементы равны проверяем, чтобы элемент не повторялся в результирующем массиве
            if (k == 0 || result[k - 1] != A[i]) {
                result[k++] = A[i]; 
            }
            i++; 
            j++; 
        }
        else if (A[i] < B[j]) { // Если элемент A меньше элемента B
            if (k == 0 || result[k - 1] != A[i]) {
                result[k++] = A[i]; // Добавляем элемент в результат
            }
            i++; // Переходим к следующему элементу в массиве A
        }
        else { // Если элемент B меньше элемента A
            if (k == 0 || result[k - 1] != B[j]) {
                result[k++] = B[j]; 
            }
            j++; 
        }
    }

    // Добавляем оставшиеся элементы из A
    while (i < SIZE) {
        if (k == 0 || result[k - 1] != A[i]) { // Проверяем уникальность
            result[k++] = A[i]; // Добавляем элемент в результат
        }
        i++; // Переходим к следующему элементу в массиве A
    }

    // Добавляем оставшиеся элементы из B
    while (j < SIZE) {
        if (k == 0 || result[k - 1] != B[j]) { 
            result[k++] = B[j]; 
        }
        j++; // Переходим к следующему элементу в массиве B
    }

    return k; // Возвращаем количество элементов в объединении
}

// Функция для нахождения A без B 
int differenceAB(int A[], int B[], int result[]) {
    int i = 0, j = 0, k = 0; 

    while (i < SIZE && j < SIZE) { 
        if (A[i] < B[j]) { 
            if (k == 0 || result[k - 1] != A[i]) { // Проверяем уникальность
                result[k++] = A[i]; 
            }
            i++; 
        }
        else if (A[i] == B[j]) { // Если элементы равны
            i++; // Переходим к следующему элементу в массиве A
            j++; // Переходим к следующему элементу в массиве B
        }
        else { // Если элемент B меньше элемента A
            j++; // Переходим к следующему элементу в массиве B
        }
    }

    // Добавляем оставшиеся элементы из A
    while (i < SIZE) {
        if (k == 0 || result[k - 1] != A[i]) { 
            result[k++] = A[i]; 
        }
        i++; 
    }

    return k; // Возвращаем количество элементов в A без B
}

// Функция для нахождения B без A 
int differenceBA(int A[], int B[], int result[]) {
    int i = 0, j = 0, k = 0; 

    while (i < SIZE && j < SIZE) { 
        if (B[j] < A[i]) { // Если элемент B меньше элемента A
            if (k == 0 || result[k - 1] != B[j]) { 
                result[k++] = B[j]; 
            }
            j++; 
        }
        else if (A[i] == B[j]) { // Если элементы равны
            i++; // Переходим к следующему элементу в массиве A
            j++; // Переходим к следующему элементу в массиве B
        }
        else { // Если элемент A меньше элемента B
            i++; 
        }
    }

    // Добавляем оставшиеся элементы из B
    while (j < SIZE) {
        if (k == 0 || result[k - 1] != B[j]) {
            result[k++] = B[j]; 
        }
        j++; 
    }

    return k; // Возвращаем количество элементов в B без A
}

// Функция для вывода массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) { // Проходим по всем элементам массива
        cout << arr[i] << " "; // Выводим текущий элемент
    }
    cout << endl; // Печатаем новую строку после вывода всех элементов
}

int main() {
    int A[SIZE], B[SIZE]; // Объявляем массивы A и B заданного размера

    // Ввод массива A
    cout << "Enter 10 elements for array A: "; // Запрашиваем элементы для массива A
    for (int i = 0; i < SIZE; i++) {
        cin >> A[i]; // Считываем элементы массива A
    }

    // Ввод массива B
    cout << "Enter 10 elements for array B: "; // Запрашиваем элементы для массива B
    for (int i = 0; i < SIZE; i++) {
        cin >> B[i]; // Считываем элементы массива B
    }

    // Сортируем массивы
    mergeSort(A, 0, SIZE - 1); // Сортируем массив A
    mergeSort(B, 0, SIZE - 1); // Сортируем массив B

    int result[SIZE * 2]; // Создаём массив для хранения результата, максимальный размер 20
    int choice; // Переменная для хранения выбора пользователя

    // Меню выбора операции
    cout << "Choose an operation:\n"; 
    cout << "1. Union of A and B\n"; // Опция объединения
    cout << "2. Intersection of A and B\n"; // Опция пересечения
    cout << "3. A without B\n"; // Опция A без B
    cout << "4. B without A\n"; // Опция B без A
    cout << "Enter your choice: "; 
    cin >> choice; 

    int size = 0; // Переменная для хранения размера результата

    // Обработка выбора пользователя
    switch (choice) {
    case 1: 
        size = unionArrays(A, B, result);
        cout << "Union of A and B: "; 
        break; 
    case 2: 
        size = intersection(A, B, result); 
        cout << "Intersection of A and B: "; 
        break; 
    case 3: 
        size = differenceAB(A, B, result); 
        cout << "A without B: "; 
        break; 
    case 4: 
        size = differenceBA(A, B, result); 
        cout << "B without A: "; 
        break; 
    default: 
        cout << "Invalid choice!"; 
        return 1; 
    }

    printArray(result, size);

    return 0; 
}

